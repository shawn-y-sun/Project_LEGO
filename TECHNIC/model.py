# TECHNIC/model.py

from abc import ABC, abstractmethod
import pandas as pd
import numpy as np
import statsmodels.api as sm
from typing import Optional, Any, Type, Dict
from statsmodels.stats.outliers_influence import variance_inflation_factor
from .test import NormalityTest, StationarityTest
from .testset import TestSetBase
from .report import OLS_ModelReport


class ModelBase(ABC):
    """
    Abstract base class for statistical models, including optional test and reporting hooks.
    """
    def __init__(
        self,
        X: pd.DataFrame,
        y: pd.Series,
        X_out: Optional[pd.DataFrame] = None,
        y_out: Optional[pd.Series] = None,
        testset_cls: Optional[Type[Any]] = None,
        report_cls: Optional[Type[Any]] = None
    ):
        self.X = X
        self.y = y
        self.X_out = X_out if X_out is not None else pd.DataFrame()
        self.y_out = y_out if y_out is not None else pd.Series(dtype=float)
        self.testset_cls = testset_cls
        self.report_cls = report_cls
        self.coefs_ = None
        self.is_fitted = False

    @abstractmethod
    def fit(self) -> "ModelBase":
        """
        Fit the model to in-sample data. Returns self.
        """
        ...

    @abstractmethod
    def predict(self, X_new: pd.DataFrame) -> pd.Series:
        """
        Generate predictions for new data.
        """
        ...

    @property
    def y_pred_out(self) -> pd.Series:
        """
        Out-of-sample predictions generated by calling predict on X_out.
        """
        if self.X_out is None or self.X_out.empty:
            return pd.Series(dtype=float)
        return self.predict(self.X_out)
    
    @property
    def report(self) -> Any:
        """
        Build and return the report instance using the configured report_cls
        and all of this model’s data and measure attributes.
        """
        if not self.report_cls:
            raise ValueError("No report_cls provided for building report.")
        return self.report_cls(
            X=self.X,
            y=self.y,
            y_fitted_in=getattr(self, 'y_fitted_in', None),
            X_out=self.X_out,
            y_out=self.y_out,
            y_pred_out=self.y_pred_out,
            in_perf_measures=getattr(self, 'in_perf_measures', {}),
            out_perf_measures=getattr(self, 'out_perf_measures', {}),
            test_measures=getattr(self, 'test_measures', {}),
            param_measures=getattr(self, 'param_measures', {})
        )


class OLS(ModelBase):
    """
    Ordinary Least Squares regression wrapper. Stores fit results,
    and provides performance and parameter measure properties.
    """
    def __init__(
        self,
        X: pd.DataFrame,
        y: pd.Series,
        X_out: Optional[pd.DataFrame] = None,
        y_out: Optional[pd.Series] = None,
        testset_cls: Optional[Type[Any]] = None,
        report_cls: Optional[Type[Any]] = None
    ):
        super().__init__(
            X, y,
            X_out=X_out,
            y_out=y_out,
            testset_cls=TestSetBase,
            report_cls=OLS_ModelReport
        )
        # Statsmodels result and related attributes
        self.fitted: Optional[sm.regression.linear_model.RegressionResultsWrapper] = None
        self.params: Optional[pd.Series] = None
        self.pvalues: Optional[pd.Series] = None
        self.rsquared: Optional[float] = None
        self.rsquared_adj: Optional[float] = None
        self.y_fitted_in: Optional[pd.Series] = None
        self.resid: Optional[pd.Series] = None
        self.bse: Optional[pd.Series] = None
        self.vif: Optional[pd.Series] = None

    def fit(self) -> "OLS":
        """
        Fit OLS using statsmodels and store key results.
        """
        Xc = sm.add_constant(self.X)
        result = sm.OLS(self.y, Xc).fit()
        self.fitted = result
        self.params = result.params
        self.pvalues = result.pvalues
        self.rsquared = result.rsquared
        self.rsquared_adj = result.rsquared_adj
        self.y_fitted_in = result.fittedvalues
        self.resid = result.resid
        self.bse = result.bse
        # Compute VIF including intercept
        vz = variance_inflation_factor
        vif_dict = {col: vz(Xc.values, i) for i, col in enumerate(Xc.columns)}
        self.vif = pd.Series(vif_dict)
        self.coefs_ = self.params
        self.is_fitted = True
        return self

    def predict(self, X_new: pd.DataFrame) -> pd.Series:
        """
        Predict using the fitted statsmodels results.
        """
        if not self.is_fitted or self.fitted is None:
            raise ValueError("Model has not been fitted yet.")
        Xc_new = sm.add_constant(X_new, has_constant='add')
        return self.fitted.predict(Xc_new)

    @property
    def param_measures(self) -> Dict[str, Dict[str, Any]]:
        """
        Parameter measures: coefficient, pvalue, VIF, and standard error for each term.
        """
        return {
            var: {
                'coef': float(self.params[var]),
                'pvalue': float(self.pvalues[var]),
                'vif': float(self.vif.get(var, np.nan)),
                'std': float(self.bse.get(var, np.nan))
            }
            for var in self.params.index
        }

    @property
    def in_perf_measures(self) -> Dict[str, Any]:
        """
        In-sample performance: R², adj-R², ME, MAE, RMSE.
        """
        errors = self.y - self.y_fitted_in
        return {
            'r2': float(self.rsquared),
            'adj_r2': float(self.rsquared_adj),
            'me': float(np.max(np.abs(errors))),
            'mae': float(np.mean(np.abs(errors))),
            'rmse': float(np.sqrt((errors ** 2).mean()))
        }

    @property
    def out_perf_measures(self) -> Dict[str, Any]:
        """
        Out-of-sample performance using y_pred_out.
        """
        if self.X_out.empty or self.y_out.empty:
            return {}
        errors = self.y_out - self.y_pred_out
        return {
            'me': float(np.max(np.abs(errors))),
            'mae': float(np.mean(np.abs(errors))),
            'rmse': float(np.sqrt((errors ** 2).mean()))
        }

    PPNR_OLS_test_alphas: Dict[str, float] = {
    'NormalityTest': 0.05,
    'StationarityTest': 0.05
    }
    
    def build_tests(
        self,
        alphas: Dict[str, float] = PPNR_OLS_test_alphas
    ) -> TestSetBase:
        """
        Build and return a TestSetBase (or custom testset_cls) configured
        with NormalityTest and StationarityTest using individual alpha levels.
        :param alphas: dict mapping "NormalityTest" and "StationarityTest" to alpha values.
        """

        TestSetClass = self.testset_cls or TestSetBase

        test_kwargs: Dict[Type, Dict[str, Any]] = {
            NormalityTest:   {"resid": self.resid, "alpha": alphas.get("NormalityTest", 0.05)},
            StationarityTest:{"series": self.resid, "alpha": alphas.get("StationarityTest", 0.05)}
        }

        return TestSetClass(test_kwargs)
    
    @property
    def tests(self) -> TestSetBase:
        """
        Build and return the TestSet for this model.
        """
        return self.build_tests()